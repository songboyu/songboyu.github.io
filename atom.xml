<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Songboyu's Blog]]></title>
  <subtitle><![CDATA[生活赋予我们一种巨大而又无限高贵的礼品，这就是青春。]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://yoursite.com/"/>
  <updated>2014-12-17T06:33:33.620Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name><![CDATA[Songboyu]]></name>
    
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[学习笔记：1.1 左旋转字符串]]></title>
    <link href="http://yoursite.com/2014/12/17/taopp-1-1/"/>
    <id>http://yoursite.com/2014/12/17/taopp-1-1/</id>
    <published>2014-12-17T02:19:19.000Z</published>
    <updated>2014-12-17T06:33:16.000Z</updated>
    <content type="html"><![CDATA[<p><a href="https://github.com/julycoding/The-Art-Of-Programming-By-July/blob/master/ebook/zh/01.01.md" target="_blank" rel="external">源地址</a></p>
<h2 id="题目描述">题目描述</h2>
<p>给定一个字符串，要求把字符串前面的<code>m</code>个字符移动到字符串的尾部，如把字符串<code>abcdef</code>前面的2个字符’a’和’b’移动到字符串的尾部，使得原字符串变成字符串<code>cdefab</code>。<br>请写一个函数完成此功能，要求对长度为<code>n</code>的字符串操作的时间复杂度为 O(n)，空间复杂度为 O(1)。<br><a id="more"></a></p>
<h2 id="解法">解法</h2>
<h3 id="×_暴力移位法">× 暴力移位法</h3>
<p>最容易想到的解法，每次内循环将字符串第一个字符移动到尾部，移动<code>m</code>次。<br>时间复杂度 O(m * n)，空间复杂度O(1)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> LeftRotateString_01(<span class="keyword">char</span>* s, <span class="keyword">int</span> m){</div><div class="line">    <span class="keyword">int</span> n = <span class="built_in">strlen</span>(s);</div><div class="line">    m %= n;</div><div class="line">    <span class="keyword">while</span>(m--){</div><div class="line">        <span class="keyword">char</span> t = s[<span class="number">0</span>];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; i++){</div><div class="line">            s[i-<span class="number">1</span>] = s[i];</div><div class="line">        }</div><div class="line">        s[n-<span class="number">1</span>] = t;</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="×_空间换时间法1">× 空间换时间法1</h3>
<p>申请一块<code>2n</code>长度的内存，将字符串复制两遍到新内存，再截取<code>m</code>到<code>n+m</code>之间内容作为结果<br>时间复杂度 O(2n)，空间复杂度O(2n)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> LeftRotateString_02(<span class="keyword">char</span>* s, <span class="keyword">int</span> m){</div><div class="line">    <span class="keyword">int</span> n = <span class="built_in">strlen</span>(s);</div><div class="line">    m %= n;</div><div class="line">    <span class="keyword">char</span> p[<span class="number">2</span>*n];</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++){</div><div class="line">        p[n+i] = p[i] = s[i];</div><div class="line">    }</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++){</div><div class="line">        s[i] = p[i+m];</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="×_空间换时间法2">× 空间换时间法2</h3>
<p>申请一块<code>m</code>长度的内存，存储要移动的所有字符。<br>将字符串第<code>i</code>位赋值为<code>i+m</code>位字符，再将结尾赋值为新内存内容。<br>时间复杂度 O(n+m)，空间复杂度O(m)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> LeftRotateString_03(<span class="keyword">char</span>* s, <span class="keyword">int</span> m){</div><div class="line">    <span class="keyword">int</span> n = <span class="built_in">strlen</span>(s);</div><div class="line">    m %= n;</div><div class="line">    <span class="keyword">char</span> tmp[m];</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++){</div><div class="line">        tmp[i] = s[i];</div><div class="line">    }</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n-m; i++){</div><div class="line">        s[i] = s[i + m];</div><div class="line">    }</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++){</div><div class="line">        s[i+n-m] = tmp[i];</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="×_分组交换法">× 分组交换法</h3>
<p>算法步骤示例（假设m=3）：</p>
<ul>
<li><code>abc</code> def ghi jk</li>
<li>def <code>abc</code> ghi jk</li>
<li>def ghi <code>abc</code> jk</li>
<li>def ghi jk <code>abc</code></li>
</ul>
<p><strong> 步骤1 </strong><br>每m个字符分为一组<br>将第一组不断向后移位，直到后面的字符数不足m<br>这一过程中需要两个指针p1,p2记录位置，对照上述步骤示意：<br><img src="/img/taopp/1.1/1.png" alt=""></p>
<ol>
<li>交换p1,p2字符</li>
<li>p1++; p2++;</li>
</ol>
<p><img src="/img/taopp/1.1/2.png" alt=""></p>
<p><strong> 步骤2 </strong><br>对照上述步骤示意，步骤一结束后，状态为第三行，p2指向<code>j</code><br>然后，对于<code>abc</code>后面的每一个字符，分别向前移位m次，p1++; p2++;</p>
<p>时间复杂度 O(m + n)，空间复杂度O(1)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> swap(<span class="keyword">char</span>* a, <span class="keyword">char</span>* b){</div><div class="line">    <span class="keyword">char</span> temp = *a;</div><div class="line">    *a = *b;</div><div class="line">    *b = temp;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">void</span> LeftRotateString_03(<span class="keyword">char</span>* s, <span class="keyword">int</span> m){</div><div class="line">    <span class="keyword">int</span> n = <span class="built_in">strlen</span>(s);</div><div class="line">    m %= n;</div><div class="line">    <span class="keyword">int</span> p1 = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> p2 = m;</div><div class="line">    <span class="keyword">int</span> step = m;</div><div class="line">    <span class="comment">// 步骤1</span></div><div class="line">    <span class="comment">// 判断p2+m-1是否越界</span></div><div class="line">    <span class="keyword">while</span>(p2+m-<span class="number">1</span> &lt; n){</div><div class="line">        step = m;</div><div class="line">        <span class="keyword">while</span>(step--){</div><div class="line">            <span class="comment">// 交换p1,p2</span></div><div class="line">            swap(&s[p1], &s[p2]);</div><div class="line"></div><div class="line">            p1++;</div><div class="line">            p2++;</div><div class="line">        }</div><div class="line">    }</div><div class="line">    <span class="comment">// 步骤2</span></div><div class="line">    <span class="keyword">int</span> count = n - p2;</div><div class="line">    <span class="keyword">while</span>(count--){</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=p2; i&gt;p1; i--){</div><div class="line">            swap(&s[i], &s[i-<span class="number">1</span>]);</div><div class="line">        }</div><div class="line">        p1++;</div><div class="line">        p2++;</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="√_三步翻转法（STL的rotate三种迭代器之一）">√ 三步翻转法（STL的rotate三种迭代器之一）</h3>
<p>这大概是最简单最巧妙的方法了<br>July给出了一张帮助理解的示意图<br><img src="/img/taopp/1.1/3.png" alt=""></p>
<ol>
<li>伸出两手，掌心面向自己，左手在上右手在下</li>
<li>翻转左手，背向自己</li>
<li>翻转右手，背向自己</li>
<li>翻转两手，掌心面向自己</li>
</ol>
<p>结果右手在上左手在下</p>
<p><code>n=10, m=5</code><br>初始状态： <code>12345</code> 678910<br>结束状态： 678910 <code>12345</code></p>
<p>时间复杂度 O(n)，空间复杂度O(1)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> ReverseString(<span class="keyword">char</span>* s,<span class="keyword">int</span> start, <span class="keyword">int</span> end){</div><div class="line">    <span class="keyword">while</span>(start &lt; end){</div><div class="line">        <span class="keyword">char</span> t = s[start];</div><div class="line">        s[start++] = s[end];</div><div class="line">        s[end--] = t;</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">void</span> LeftRotateString_04(<span class="keyword">char</span>* s, <span class="keyword">int</span> m){</div><div class="line">    <span class="keyword">int</span> n = <span class="built_in">strlen</span>(s);</div><div class="line">    m %= n;</div><div class="line">    ReverseString(s, <span class="number">0</span>, m-<span class="number">1</span>);</div><div class="line">    ReverseString(s, m, n-<span class="number">1</span>);</div><div class="line">    ReverseString(s, <span class="number">0</span>, n-<span class="number">1</span>);</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="√_gcd插值法（STL的rotate三种迭代器之一）">√ gcd插值法（STL的rotate三种迭代器之一）</h3>
<blockquote>
<p>ys：这条思路个人认为绝妙，也正好说明了数学对算法的重要影响。</p>
</blockquote>
<h4 id="对于m、n互质的情况">对于m、n互质的情况</h4>
<p>用<code>(j + m) % n</code>即可遍历每一个字符，且间隔为<code>m</code>，没有重复<br>因此可以将遍历过程中每一个字符赋值到前一个位置，即可达到左旋转字符串的目的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span> tmp = s[<span class="number">0</span>];</div><div class="line"><span class="keyword">int</span> next = <span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = m % n; j != n; j = (j + m) % n){</div><div class="line">    s[next] = s[j];</div><div class="line">    next = j;</div><div class="line">}</div><div class="line">s[next] = tmp;</div></pre></td></tr></table></figure>

<h4 id="对于m、n非互质的情况">对于m、n非互质的情况</h4>
<p>用<code>(j + m) % n</code>遍历字符串时，未遍历完成就会出现一个位置使<code>(j + m) % n</code>为<code>0</code>，即(j + m)整除了n。<br>继续进行遍历将回到之前位置陷入循环，没有意义。这样的一个循环构成一个循环链。</p>
<p><strong>一共有多少个循环链呢？</strong></p>
<p>我们换一个位置1开始，用<code>(1 + j + m) % n</code>遍历，发现一样陷入了循环。<br>我们再多换几个位置<code>i</code>开始，用<code>(i + j + m) % n</code>遍历，发现都会陷入循环，而且链上的字符数固定。</p>
<p>这样，我们只要求出每个循环链上的字符个数，即可得出<strong>一共有多少循环链</strong><br>然后遍历每一条循环链，即可达到左旋转字符串的目的！</p>
<pre><code>我们发现每条循环链上都出现一个位置使 (<span class="built_in">i</span> + <span class="built_in">j</span> + m) <span class="comment">% n 为 i</span>
即存在正整数 k,使得 n|km，且min(k)即是每条循环链上字符个数(<span class="string">'3|9'</span> 表示<span class="number">3</span>能整除<span class="number">9</span>)

设：
n = <span class="transposed_variable">n'</span> * <span class="built_in">gcd</span>(n,m)
m = <span class="transposed_variable">m'</span> * <span class="built_in">gcd</span>(n,m)

由于 n|km 
所以 <span class="transposed_variable">n'</span>|<span class="transposed_variable">km'</span>

由于 <span class="transposed_variable">n'</span>和<span class="transposed_variable">m'</span> 互素
所以 <span class="transposed_variable">n'</span>|k 
即 (n/<span class="built_in">gcd</span>(n,m)|k)

所以每条循环链上有 n/<span class="built_in">gcd</span>(n,m) 个字符
所以一共有<span class="built_in">gcd</span>(n,m)个循环链！
</code></pre><p>gcd(求最大公约数)代码如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> gcd(<span class="keyword">int</span> m, <span class="keyword">int</span> n){</div><div class="line">    <span class="keyword">int</span> r;</div><div class="line">    <span class="keyword">while</span> ((r = m % n)){</div><div class="line">        m = n;</div><div class="line">        n = r;</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> n;</div><div class="line">}</div></pre></td></tr></table></figure>

<h4 id="小结">小结</h4>
<p>针对以上两种情况，可以得出如下代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> LeftRotateString_06(<span class="keyword">char</span>* s, <span class="keyword">int</span> m){</div><div class="line">    <span class="keyword">int</span> n = <span class="built_in">strlen</span>(s);</div><div class="line">    m %= n;</div><div class="line">    <span class="keyword">int</span> d = gcd(n, m);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; d; i ++){</div><div class="line">        <span class="keyword">char</span> tmp = s[i];</div><div class="line">        <span class="keyword">int</span> next = i;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = (i + m) % n; j != i; j = (j + m) % n){</div><div class="line">            s[next] = s[j];</div><div class="line">            next = j;</div><div class="line">        }</div><div class="line">        s[next] = tmp;</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>时间复杂度 O(n)，空间复杂度O(1)</p>
<h2 id="获得代码">获得代码</h2>
<p><a href="https://github.com/songboyu/The-Art-Of-Programming/blob/master/1.string/1.1.c" target="_blank" rel="external">学习笔记：1.1字符串翻转</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="https://github.com/julycoding/The-Art-Of-Programming-By-July/blob/master/ebook/zh/01.01.md" target="_blank" rel="external">源地址</a></p>
<h2 id="题目描述">题目描述</h2>
<p>给定一个字符串，要求把字符串前面的<code>m</code>个字符移动到字符串的尾部，如把字符串<code>abcdef</code>前面的2个字符’a’和’b’移动到字符串的尾部，使得原字符串变成字符串<code>cdefab</code>。<br>请写一个函数完成此功能，要求对长度为<code>n</code>的字符串操作的时间复杂度为 O(n)，空间复杂度为 O(1)。<br>]]>
    
    </summary>
    
      <category term="程序员编程艺术" scheme="http://yoursite.com/tags/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/"/>
    
      <category term="c" scheme="http://yoursite.com/tags/c/"/>
    
      <category term="string" scheme="http://yoursite.com/tags/string/"/>
    
      <category term="程序员编程艺术" scheme="http://yoursite.com/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/"/>
    
      <category term="c" scheme="http://yoursite.com/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/c/"/>
    
      <category term="string" scheme="http://yoursite.com/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/c/string/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Firefox调试实战----解析华为网盘内容下载链接]]></title>
    <link href="http://yoursite.com/2014/12/13/get-dbank-download-url/"/>
    <id>http://yoursite.com/2014/12/13/get-dbank-download-url/</id>
    <published>2014-12-13T10:22:42.000Z</published>
    <updated>2014-12-14T08:16:57.000Z</updated>
    <content type="html"><![CDATA[<p>调试工具：firefox浏览器<br>语言：python</p>
<h2 id="任务详情：">任务详情：</h2>
<p>对华为<a href="http://dl.vmall.com/c0xn8jav5v" target="_blank" rel="external">网盘下载页</a>解析，获得最终可下载链接。<br><a id="more"></a><br><img src="/img/dbank/1.png" alt="下载页详情"></p>
<h2 id="任务实现">任务实现</h2>
<h3 id="找到下载地址解密函数">找到下载地址解密函数</h3>
<p>按<code>F12</code>进入firefox的控制台</p>
<ul>
<li>通过对下载按钮<img src="/img/dbank/2.png" alt="">审查元素，发现执行了<code>dbank.securelink.downloadfile(this)</code>这样一段js代码，<br><img src="/img/dbank/3.png" alt=""></li>
<li>进入调试器</li>
<li>在右侧搜索框<img src="/img/dbank/5.png" alt="">中搜索<code>@downloadfile</code>找到函数体，</li>
<li>点击左下角大括号图标<img src="/img/dbank/6.png" alt="">格式化代码</li>
<li>函数很简单，前几个判断都<code>return false</code>，在<code>downloadfile</code>函数中找到了真正有用的一句<br><img src="/img/dbank/7.png" alt="downloadfile函数"></li>
<li>搜索<code>@download_dbankplugin</code>进入该函数，很难判断进入了哪个分支</li>
<li>在第一个分支前添加断点，点击下载链接，果然停在了这~<br><img src="/img/dbank/8.png" alt=""><br>首先了解一下firebug的调试工具：<br>恢复<code>F8</code>：<img src="/img/dbank/9.png" alt=""><br>跨越<code>F10</code>：<img src="/img/dbank/10.png" alt=""><br>步进<code>F11</code>：<img src="/img/dbank/11.png" alt=""><br>步出<code>Shift</code>+<code>F11</code>：<img src="/img/dbank/12.png" alt=""></li>
<li>几次步进步出之后发现进入了<code>download_dbankcommon</code>函数<br>注意：如果用步进，<code>jquery</code>代码也会检查…，所有遇到<code>jquery</code>语法时直接跨越就行了<br>经过在<code>download_dbankcommon</code>函数几次的步进步出，确定进入了<code>installPluginconfig</code>函数<br><img src="/img/dbank/13.png" alt=""></li>
<li>经过在这个函数中艰苦的添加断点、步进步出、跨越确定进入了<code>vercode_success</code>函数<br>并终于发现了<code>decrypt</code>（解密）字样<br><img src="/img/dbank/14.png" alt=""><br>从以上代码可以看出，对<code>decrypt</code>函数返回值简单处理后，进行了<code>location.href = g</code>操作<br>可以确定，<code>g</code>就是下载地址！！</li>
</ul>
<h3 id="解析下载地址是如何进行解密的">解析下载地址是如何进行解密的</h3>
<ul>
<li>抱着必胜的信念，我们步进<code>decrypt</code>函数<br><img src="/img/dbank/15.png" alt=""><br>代码很清晰也很简单，先写下来：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> base64</div><div class="line"><span class="keyword">import</span> md5</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">decrypt</span><span class="params">(g, e)</span>:</span></div><div class="line">    g = base64.decodestring(g)</div><div class="line">    <span class="keyword">if</span> e[:<span class="number">2</span>] == <span class="string">'ea'</span>:</div><div class="line">        d = g</div><div class="line">    <span class="keyword">elif</span> e[:<span class="number">2</span>] == <span class="string">'eb'</span>:</div><div class="line">        d = b(g, c(e, e))</div><div class="line">    <span class="keyword">elif</span> e[:<span class="number">2</span>] == <span class="string">'ed'</span>:</div><div class="line">        d = b(g, md5.md5(e).hexdigest())</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        d = g</div><div class="line">    <span class="keyword">return</span> d</div></pre></td></tr></table></figure>

<p>首要任务就是拿到<code>g</code>,<code>e</code>，查看变量<br><img src="/img/dbank/16.png" alt=""><br>从代码和上图可以知道<code>g</code>是一个base64编码过的串，<code>e</code>未知<br>查看<code>decrypt</code>的调用处<br><img src="/img/dbank/24.png" alt=""><br>分别看到<code>downloadurl</code>和<code>encrykey</code>关键字<br>查找网页源代码中找到了这两个字样，大致可以确定就是<code>g</code>和<code>e</code><br><img src="/img/dbank/18.png" alt=""><br><img src="/img/dbank/17.png" alt=""></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> requests</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">dbank_final_url</span><span class="params">(url)</span>:</span></div><div class="line">    resp = requests.get(url)</div><div class="line">    html = resp.content</div><div class="line">    g = re.findall(<span class="string">r'"downloadurl":"(.*?)"'</span>, html)[<span class="number">0</span>]</div><div class="line">    e = re.findall(<span class="string">r'"encryKey":"(.*?)"'</span>, html)[<span class="number">0</span>]</div><div class="line">    <span class="keyword">return</span> decrypt(g, e)</div></pre></td></tr></table></figure>

<ul>
<li>拿到<code>decrypt</code>函数的参数后分析这段代码，发现它调用了两个函数分别是<code>c</code>和<code>b</code></li>
</ul>
<h4 id="子函数b">子函数b</h4>
<p>逐步步进，由于<code>e</code>的值是<code>ed43487215</code>以’ed’开头，所以没有进入<code>c</code>函数，而是进入了下一个判断<br>在这个判断中也包含<code>b</code>函数，我们步进去<br><img src="/img/dbank/19.png" alt=""><br>换成python实现</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">b</span><span class="params">(d, e)</span>:</span></div><div class="line">    k = len(e)</div><div class="line">    f = len(d)</div><div class="line">    g = <span class="string">''</span></div><div class="line">    h = <span class="number">0</span></div><div class="line">    <span class="keyword">while</span> h &lt; f:</div><div class="line">        j = ord(d[h]) ^ ord(e[h%k])</div><div class="line">        g += chr(j)</div><div class="line">        h += <span class="number">1</span></div><div class="line">    <span class="keyword">return</span> g</div></pre></td></tr></table></figure>

<h4 id="子函数c">子函数c</h4>
<ul>
<li><code>b</code>函数找到了，那么<code>c</code>函数怎么办呢？<br>Firebug可以在内部调试中修改变量的值，从而改变js代码的执行。<br>我们可以在<code>switch(f)</code>执行之前设置断点<br><img src="/img/dbank/21.png" alt=""><br>然后刷新页面，重新点击下载链接，在调试器右侧变量处修改<code>e</code>的值为<code>eb24802980</code>回车<br><img src="/img/dbank/22.png" alt=""><br>这样我们就顺利的进入了<code>c</code>函数<br><img src="/img/dbank/20.png" alt=""><br>换成python实现</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">c</span><span class="params">(h, l)</span>:</span></div><div class="line">    k = range(<span class="number">256</span>)</div><div class="line">    e = <span class="number">0</span></div><div class="line">    g = <span class="string">''</span></div><div class="line">    <span class="keyword">for</span> f <span class="keyword">in</span> range(<span class="number">256</span>):</div><div class="line">        e = (e + k[f] + ord(h[f%len(h)])) % <span class="number">256</span></div><div class="line">        d = k[f]</div><div class="line">        k[f] = k[e]</div><div class="line">        k[e] = d</div><div class="line">    f = <span class="number">0</span></div><div class="line">    e = <span class="number">0</span></div><div class="line">    <span class="keyword">for</span> m <span class="keyword">in</span> range(len(l)):</div><div class="line">        f = (f + <span class="number">1</span>) % <span class="number">256</span></div><div class="line">        e = (e + k[f]) % <span class="number">256</span></div><div class="line">        d = k[f]</div><div class="line">        k[f] = k[e]</div><div class="line">        k[e] = d</div><div class="line">        g += chr(ord(l[m]) ^ k[(k[f] + k[e]) % <span class="number">256</span>])</div><div class="line">    <span class="keyword">return</span> g</div></pre></td></tr></table></figure>

<h2 id="测试">测试</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    <span class="keyword">print</span> dbank_final_url(<span class="string">'http://dl.vmall.com/c0xn8jav5v'</span>)</div></pre></td></tr></table></figure>

<p><img src="/img/dbank/23.png" alt=""><br>真的可以下载耶~</p>
<h2 id="获得代码">获得代码</h2>
<p><a href="/py/dbank.py">本例代码地址</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>调试工具：firefox浏览器<br>语言：python</p>
<h2 id="任务详情：">任务详情：</h2>
<p>对华为<a href="http://dl.vmall.com/c0xn8jav5v" target="_blank" rel="external">网盘下载页</a>解析，获得最终可下载链接。<br>]]>
    
    </summary>
    
      <category term="dbank" scheme="http://yoursite.com/tags/dbank/"/>
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="url" scheme="http://yoursite.com/tags/url/"/>
    
      <category term="firefox" scheme="http://yoursite.com/tags/firefox/"/>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[python实现简易中文输入法（四）：拼音流切分]]></title>
    <link href="http://yoursite.com/2014/12/12/python-simple-chinese-input-method-04/"/>
    <id>http://yoursite.com/2014/12/12/python-simple-chinese-input-method-04/</id>
    <published>2014-12-11T17:29:35.000Z</published>
    <updated>2014-12-13T11:03:27.000Z</updated>
    <content type="html"><![CDATA[<ul>
<li>前一博客：将拼音序列如<code>[&#39;ce&#39;,&#39;shi&#39;,&#39;zhong&#39;,&#39;wen&#39;,&#39;shu&#39;,&#39;ru&#39;,&#39;fa&#39;]</code>转为汉字串,</li>
<li>本篇博客：如何将<code>ceshizhongwenshurufa</code>这样的拼音流切分为以上形式。</li>
</ul>
<h2 id="建立拼音Tire树">建立拼音Tire树</h2>
<p>建立一个如下图所示的Tire树结构：<br><img src="/img/pinyin-input-method/pinyin-trie.png" alt="拼音Tire树"></p>
<ul>
<li>在音节树中, 根结点的儿子为所有的可作为拼音开头的字母。</li>
<li>再有这些字母生出合法的音节, 其中灰色的节点表示不可终结。</li>
<li>通过对树的访问很方便地判断哪些是合法拼音, 哪些是合法拼音的一部分。</li>
<li>首先需要一个所有有效拼音的列表 <a href="https://raw.githubusercontent.com/songboyu/NLP-test/master/pinyin/pinyin_list.txt" target="_blank" rel="external">pinyin_list.txt</a><br><a id="more"></a><br>Node节点结构</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.word = <span class="keyword">None</span></div><div class="line">        self.children = {}</div></pre></td></tr></table></figure>

<p>后续可以用到两个方法：</p>
<ul>
<li><code>insert</code>: 初始化Tire树时使用</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, word)</span>:</span></div><div class="line">    node = self.root</div><div class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> word:</div><div class="line">        <span class="keyword">if</span> c <span class="keyword">not</span> <span class="keyword">in</span> node.children:</div><div class="line">            node.children[c] = Node()</div><div class="line">        node = node.children[c]</div><div class="line">    node.word = word</div></pre></td></tr></table></figure>

<ul>
<li><code>find_initial_with</code>: 判断拼音序列是否为有效序列或有效序列的一部分</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_initial_with</span><span class="params">(self, prefix_word)</span>:</span></div><div class="line">    node = self.root</div><div class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> prefix_word:</div><div class="line">        <span class="keyword">if</span> c <span class="keyword">not</span> <span class="keyword">in</span> node.children:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">        node = node.children[c]</div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> node:</div><div class="line">        <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">True</span></div></pre></td></tr></table></figure>

<h2 id="切分拼音流">切分拼音流</h2>
<p>初始化时，读取文件建立Tire树</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, pinyins)</span>:</span></div><div class="line">    self.pinyins = pinyins</div><div class="line">    <span class="comment"># 读入所有有效拼音</span></div><div class="line">    self.tree = Trie()</div><div class="line">    f = open(<span class="string">'pinyin/pinyin_list.txt'</span>)</div><div class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f:</div><div class="line">        self.tree.insert(line.split()[<span class="number">0</span>])</div><div class="line">    f.close()</div></pre></td></tr></table></figure>

<p>切分的主函数流程<br><img src="/img/pinyin-input-method/pinyin-split.png" alt="切分算法流程"></p>
<ul>
<li>算法根据汉语拼音的规则, 对用户输入的合法拼音流进行切分。</li>
<li>为了程序实现上述算法，需要建立以下结构：<ol>
<li>汉语拼音声母表（包含零声母）：list</li>
<li>有效汉语拼音表：tire树</li>
<li>需要特殊处理的iuv,grn：list</li>
<li>当前输入：str</li>
<li>切分结果：list</li>
</ol>
</li>
</ul>
<p>切分拼音流主函数代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">split</span><span class="params">(self)</span>:</span></div><div class="line">    <span class="string">'''</span></div><div class="line">    分割函数</div><div class="line">    @param pinyin:  拼音串 str</div><div class="line">    @return:        分割后的拼音列表 list</div><div class="line">    '''</div><div class="line">    <span class="comment"># 可作为拼音开头的字母</span></div><div class="line">    pinyin_initials = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'e'</span>, <span class="string">'p'</span>, <span class="string">'m'</span>, <span class="string">'f'</span>, <span class="string">'d'</span>,</div><div class="line">                       <span class="string">'t'</span>, <span class="string">'n'</span>, <span class="string">'l'</span>, <span class="string">'g'</span>, <span class="string">'k'</span>, <span class="string">'h'</span>, <span class="string">'j'</span>,</div><div class="line">                       <span class="string">'q'</span>, <span class="string">'x'</span>, <span class="string">'r'</span>, <span class="string">'z'</span>, <span class="string">'c'</span>, <span class="string">'s'</span>, <span class="string">'y'</span>, <span class="string">'w'</span>]</div><div class="line">    <span class="comment"># pinyin_initials = self.tree.root.children</span></div><div class="line">    iuv = [<span class="string">'i'</span>,<span class="string">'u'</span>,<span class="string">'v'</span>]</div><div class="line">    grn = [<span class="string">'g'</span>,<span class="string">'r'</span>,<span class="string">'n'</span>]</div><div class="line"></div><div class="line">    input = <span class="string">''</span></div><div class="line">    result = []</div><div class="line"></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(self.pinyins)):</div><div class="line">        c = self.pinyins[i]</div><div class="line">        <span class="comment"># 读入字符 c</span></div><div class="line">        input += c</div><div class="line">        <span class="comment"># c是 i|u|v，并且是拼音串的首字母</span></div><div class="line">        <span class="keyword">if</span> c <span class="keyword">in</span> iuv <span class="keyword">and</span> len(input)==<span class="number">1</span>:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">False</span>,<span class="keyword">None</span></div><div class="line">        <span class="comment"># 当前拼音有效或者是有效拼音的一部分</span></div><div class="line">        <span class="keyword">if</span> self.tree.find_initial_with(input):</div><div class="line">            <span class="keyword">continue</span></div><div class="line">        <span class="comment"># c是声母</span></div><div class="line">        <span class="keyword">if</span> c <span class="keyword">in</span> pinyin_initials:</div><div class="line">            <span class="comment"># 前面的拼音为有效拼音</span></div><div class="line">            <span class="keyword">if</span> self.tree.find_initial_with(input[:-<span class="number">1</span>]):</div><div class="line">                <span class="comment"># 在c前断开</span></div><div class="line">                result.append(input[:-<span class="number">1</span>])</div><div class="line">                input = input[-<span class="number">1</span>:]</div><div class="line">                <span class="keyword">continue</span></div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                <span class="keyword">return</span> <span class="keyword">False</span>,<span class="keyword">None</span></div><div class="line">        <span class="comment"># 倒数第二个字母为 g|r|n</span></div><div class="line">        <span class="keyword">elif</span> input[-<span class="number">2</span>:-<span class="number">1</span>] <span class="keyword">in</span> grn:</div><div class="line">            <span class="comment"># 在 g|r|n 前断开有效</span></div><div class="line">            <span class="keyword">if</span> self.tree.find_initial_with(input[:-<span class="number">2</span>]):</div><div class="line">                <span class="comment"># 在 g|r|n 前断开</span></div><div class="line">                result.append(input[:-<span class="number">2</span>])</div><div class="line">                input = input[-<span class="number">2</span>:]</div><div class="line">                <span class="keyword">continue</span></div><div class="line">            <span class="comment"># 在 g|r|n 后断开有效</span></div><div class="line">            <span class="keyword">elif</span> self.tree.find_initial_with(input[:-<span class="number">1</span>]):</div><div class="line">                <span class="comment"># 在 g|r|n 后断开</span></div><div class="line">                result.append(input[:-<span class="number">1</span>])</div><div class="line">                input = input[-<span class="number">1</span>:]</div><div class="line">                <span class="keyword">continue</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="comment"># 单独断开</span></div><div class="line">            result.append(input)</div><div class="line">            input = <span class="string">''</span></div><div class="line"></div><div class="line">    result.append(input)</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="keyword">True</span>,result</div></pre></td></tr></table></figure>

<h2 id="测试">测试</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    pinyins = pinyin(<span class="string">'woaizhonghuarenmingongheguo'</span>)</div><div class="line">    <span class="keyword">print</span> pinyins.split()</div></pre></td></tr></table></figure>

<p>测试结果如下：<br><img src="/img/pinyin-input-method/pinyin-result.png" alt="测试结果"></p>
<h2 id="获得代码">获得代码</h2>
<p>代码已放到GitHub上：<a href="https://github.com/songboyu/NLP-test" target="_blank" rel="external">python实现简易中文输入法</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<ul>
<li>前一博客：将拼音序列如<code>[&#39;ce&#39;,&#39;shi&#39;,&#39;zhong&#39;,&#39;wen&#39;,&#39;shu&#39;,&#39;ru&#39;,&#39;fa&#39;]</code>转为汉字串,</li>
<li>本篇博客：如何将<code>ceshizhongwenshurufa</code>这样的拼音流切分为以上形式。</li>
</ul>
<h2 id="建立拼音Tire树">建立拼音Tire树</h2>
<p>建立一个如下图所示的Tire树结构：<br><img src="/img/pinyin-input-method/pinyin-trie.png" alt="拼音Tire树"></p>
<ul>
<li>在音节树中, 根结点的儿子为所有的可作为拼音开头的字母。</li>
<li>再有这些字母生出合法的音节, 其中灰色的节点表示不可终结。</li>
<li>通过对树的访问很方便地判断哪些是合法拼音, 哪些是合法拼音的一部分。</li>
<li>首先需要一个所有有效拼音的列表 <a href="https://raw.githubusercontent.com/songboyu/NLP-test/master/pinyin/pinyin_list.txt" target="_blank" rel="external">pinyin_list.txt</a><br>]]>
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="NLP" scheme="http://yoursite.com/tags/NLP/"/>
    
      <category term="split" scheme="http://yoursite.com/tags/split/"/>
    
      <category term="pinyin" scheme="http://yoursite.com/tags/pinyin/"/>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
      <category term="NLP" scheme="http://yoursite.com/categories/python/NLP/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[python实现简易中文输入法（三）：拼音序列转为汉字串]]></title>
    <link href="http://yoursite.com/2014/12/12/python-simple-chinese-input-method-03/"/>
    <id>http://yoursite.com/2014/12/12/python-simple-chinese-input-method-03/</id>
    <published>2014-12-11T17:15:42.000Z</published>
    <updated>2014-12-14T07:57:05.000Z</updated>
    <content type="html"><![CDATA[<p>改编自<a href="http://sobuhu.com/ml/2013/03/07/hmm-pinyin-input-method.html" target="_blank" rel="external">搜不狐</a></p>
<h2 id="建立词网格（有向图）">建立词网格（有向图）</h2>
<p>有向图中每一个节点的结构如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">GraphNode</span><span class="params">(object)</span>:</span></div><div class="line">  <span class="string">"""有向图节点"""</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, word, emission)</span>:</span></div><div class="line">    <span class="comment"># 当前节点所代表的汉字（即状态）</span></div><div class="line">    self.word = word</div><div class="line">    <span class="comment"># 当前状态发射拼音的发射概率</span></div><div class="line">    self.emission = emission</div><div class="line">    <span class="comment"># 最优路径时，从起点到该节点的最高分</span></div><div class="line">    self.max_score = <span class="number">0.0</span></div><div class="line">    <span class="comment"># 最优路径时，该节点的下一个节点，用来输出路径的时候使用</span></div><div class="line">    self.next_node = <span class="keyword">None</span></div></pre></td></tr></table></figure>

<p>建立如下结构的词网格</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">ce      [册 测 测试 侧室 侧视 ... ]</div><div class="line">shi     [是 时 视频 食品 ...]</div><div class="line">pin     [拼 品 频 拼音  ...]</div><div class="line">yin     [银 音 因数 引述 ...]</div><div class="line">shu     [输入 输入法 树 输 书 ...]</div><div class="line">ru      [入 如 汝 入法 如法...]</div><div class="line">fa      [法 发 罚 伐 ...]</div></pre></td></tr></table></figure>

<p><a id="more"></a><br>代码如下：<br>其中<code>current_position</code>表示上图词网格中每一行<br><code>self.sequence</code>表示整个网格</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graph</span><span class="params">(object)</span>:</span></div><div class="line">  <span class="string">"""图结构"""</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, pinyins, im)</span>:</span></div><div class="line">    <span class="string">"""根据拼音所对应的所有词汇组合，构造图"""</span></div><div class="line">    self.sequence = []</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(pinyins)):</div><div class="line">      pys = []</div><div class="line">      current_position = {}</div><div class="line">      <span class="comment"># pys记录以i开头的所有拼音串</span></div><div class="line">      <span class="keyword">for</span> j <span class="keyword">in</span> range(i, len(pinyins)+<span class="number">1</span>):</div><div class="line">        py = <span class="string">'|'</span>.join(pinyins[i:j])</div><div class="line">        <span class="keyword">if</span> py <span class="keyword">in</span> im.lm.emission:</div><div class="line">          pys.append(py)</div><div class="line"></div><div class="line">      <span class="comment"># current_position记录以i开头的所有拼音串，及其对应的词</span></div><div class="line">      <span class="keyword">for</span> py <span class="keyword">in</span> pys:</div><div class="line">        <span class="keyword">for</span> word,emission <span class="keyword">in</span> im.lm.emission[py].items():</div><div class="line">          node = GraphNode(word, emission)</div><div class="line">          current_position[word] = node</div><div class="line"></div><div class="line">      self.sequence.append(current_position)</div></pre></td></tr></table></figure>

<h2 id="查找概率最大路径">查找概率最大路径</h2>
<p>查找过程如下所示<br><img src="/img/pinyin-input-method/word-graph.png" alt="查找概率最大路径"></p>
<p><code>viterbi</code>开始时，先判断是否路径已在<code>cache</code>中，如果是则不进行计算。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">viterbi</span><span class="params">(self, t, k)</span>:</span></div><div class="line">    <span class="string">'''第 t 个位置出现 k 词的概率</span></div><div class="line"></div><div class="line">    @param t:   pinyin数组下标</div><div class="line">    @param k:   词</div><div class="line">    @return:    最大分值</div><div class="line">    '''</div><div class="line">    <span class="keyword">if</span> self.get_key(t,k) <span class="keyword">in</span> self.viterbi_cache:</div><div class="line">      <span class="keyword">return</span> self.viterbi_cache[self.get_key(t,k)]</div></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li>进行<code>viterbi</code>过程，读取词网格时，按词的长度作为offset，确定下一个词位置。</li>
<li>每个序列的初始概率设置为第一个词出现在句首的概率。</li>
<li>每个序列到达结尾时，要设置结束返回。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">node = self.graph.sequence[t][k]</div><div class="line"><span class="comment"># 当前词长度</span></div><div class="line">length_self = len(k.decode(<span class="string">'utf8'</span>))</div><div class="line"><span class="comment"># 开始时加载句首词词频作为初始概率</span></div><div class="line"><span class="keyword">if</span> t == <span class="number">0</span>:</div><div class="line">  init_prop = self.lm.get_init_score(k)</div><div class="line"><span class="keyword">else</span>:</div><div class="line">  init_prop = <span class="number">1</span></div><div class="line"></div><div class="line"><span class="comment"># 到达结尾</span></div><div class="line"><span class="keyword">if</span> t == len(self.pinyins)-length_self:</div><div class="line">  pinyin = <span class="string">'|'</span>.join(self.pinyins[t:t+length_self])</div><div class="line">  emission_prop = <span class="number">1</span>/self.lm.emission[pinyin][k]</div><div class="line"></div><div class="line">  node.max_score = emission_prop</div><div class="line">  self.viterbi_cache[self.get_key(t,k)] = node.max_score</div><div class="line">  <span class="keyword">return</span> node.max_score</div></pre></td></tr></table></figure>

<ul>
<li>对于不是句首与句尾的词，递归调用，继续计算下一个词出现概率。</li>
<li>递归结束返回所有序列结果中的最大概率值。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 获得下一个状态所有可能的词</span></div><div class="line">next_words = self.graph.sequence[t+length_self].keys()</div><div class="line"><span class="keyword">for</span> word <span class="keyword">in</span> next_words:</div><div class="line">  <span class="comment"># 下一个词长度</span></div><div class="line">  length_next = len(word.decode(<span class="string">'utf8'</span>))</div><div class="line">  state_transfer = self.lm.get_trans_pro(word, k)</div><div class="line">  pinyin = <span class="string">'|'</span>.join(self.pinyins[t+length_self : t+length_self+length_next])</div><div class="line"></div><div class="line">  emission_prop = <span class="number">1</span>/self.lm.emission[pinyin][word]</div><div class="line">  <span class="comment"># 递归调用，直到最后一个拼音结束</span></div><div class="line">  score = self.viterbi(t+length_self, word) * state_transfer * emission_prop * init_prop</div><div class="line"></div><div class="line">  <span class="keyword">if</span> score &gt; node.max_score:</div><div class="line">    node.max_score = score</div><div class="line">    node.next_node = self.graph.sequence[t+length_self][word]</div><div class="line"></div><div class="line">self.viterbi_cache[self.get_key(t,k)] = node.max_score</div><div class="line"><span class="keyword">return</span> node.max_score</div></pre></td></tr></table></figure>

<h2 id="主函数">主函数</h2>
<ul>
<li>以第一个拼音所对应的每一个词作为开始，进行<a href="http://en.wikipedia.org/wiki/Viterbi_algorithm" target="_blank" rel="external">viterbi算法</a>过程</li>
<li>对于每一次首词的<code>viterbi</code>过程，迭代更新<code>max_score</code>,<code>max_node</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">translate</span><span class="params">(self, pinyins)</span>:</span></div><div class="line">    <span class="string">'''</span></div><div class="line">    @param pinyins: 拼音列表</div><div class="line">    @return:        汉字串</div><div class="line">    '''</div><div class="line">    self.graph = Graph(pinyins, self)</div><div class="line">    self.viterbi_cache = {}</div><div class="line">    self.pinyins = pinyins</div><div class="line"></div><div class="line">    <span class="comment"># 从第一个字开始使用viterbi算法求解最大路径</span></div><div class="line">    words = self.graph.sequence[<span class="number">0</span>].keys()</div><div class="line">    max_node = <span class="keyword">None</span></div><div class="line">    max_score = <span class="number">0.0</span></div><div class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> words:</div><div class="line">      node = self.graph.sequence[<span class="number">0</span>][k]</div><div class="line">      score = self.viterbi(<span class="number">0</span>, k)</div><div class="line">      <span class="keyword">if</span> score &gt; max_score:</div><div class="line">        max_score = score</div><div class="line">        max_node = node</div></pre></td></tr></table></figure>

<p>由于<code>viterbi</code>过程中记录了每个<code>node</code>在最大概率路径中的<code>next_node</code>，<br>因此所有过程结束后，只需要访问<code>max_node</code>为首的一条“链表”，即可输出对应的中文路径。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 输出中文路径</span></div><div class="line">result = []</div><div class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">  result.append(max_node.word)</div><div class="line">  <span class="keyword">if</span> <span class="keyword">not</span> max_node.next_node:</div><div class="line">    <span class="keyword">break</span></div><div class="line">  max_node = max_node.next_node</div><div class="line"></div><div class="line"><span class="keyword">return</span> (<span class="string">''</span>.join(result)).decode(<span class="string">'utf8'</span>)</div></pre></td></tr></table></figure>

<h2 id="测试">测试</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> core.InputMethod <span class="keyword">import</span> InputMethod</div><div class="line"><span class="keyword">from</span> pinyin.Pinyin <span class="keyword">import</span> pinyin</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">  im = InputMethod()</div><div class="line">  <span class="keyword">print</span> im.translate([<span class="string">'a'</span>,<span class="string">'li'</span>,<span class="string">'ba'</span>,<span class="string">'ba'</span>,<span class="string">'ji'</span>,<span class="string">'tuan'</span>])</div><div class="line">  <span class="keyword">print</span> im.translate([<span class="string">'ce'</span>,<span class="string">'shi'</span>,<span class="string">'zhong'</span>,<span class="string">'wen'</span>,<span class="string">'shu'</span>,<span class="string">'ru'</span>,<span class="string">'fa'</span>])</div><div class="line">  <span class="keyword">print</span> im.translate([<span class="string">'zhong'</span>,<span class="string">'hua'</span>,<span class="string">'ren'</span>,<span class="string">'min'</span>,<span class="string">'gong'</span>,<span class="string">'he'</span>,<span class="string">'guo'</span>])</div><div class="line">  <span class="keyword">print</span> im.translate([<span class="string">'yi'</span>,<span class="string">'zhi'</span>,<span class="string">'mei'</span>,<span class="string">'li'</span>,<span class="string">'de'</span>,<span class="string">'xiao'</span>,<span class="string">'hua'</span>])</div><div class="line">  <span class="keyword">print</span> im.translate([<span class="string">'wo'</span>,<span class="string">'ai'</span>,<span class="string">'bei'</span>,<span class="string">'jing'</span>,<span class="string">'tian'</span>,<span class="string">'an'</span>,<span class="string">'men'</span>])</div></pre></td></tr></table></figure>

<p>测试结果如下：<br><img src="/img/pinyin-input-method/main-result.png" alt="测试结果"></p>
<h2 id="获得代码">获得代码</h2>
<p>代码已放到GitHub上：<a href="https://github.com/songboyu/NLP-test" target="_blank" rel="external">python实现简易中文输入法</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>改编自<a href="http://sobuhu.com/ml/2013/03/07/hmm-pinyin-input-method.html" target="_blank" rel="external">搜不狐</a></p>
<h2 id="建立词网格（有向图）">建立词网格（有向图）</h2>
<p>有向图中每一个节点的结构如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">GraphNode</span><span class="params">(object)</span>:</span></div><div class="line">  <span class="string">"""有向图节点"""</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, word, emission)</span>:</span></div><div class="line">    <span class="comment"># 当前节点所代表的汉字（即状态）</span></div><div class="line">    self.word = word</div><div class="line">    <span class="comment"># 当前状态发射拼音的发射概率</span></div><div class="line">    self.emission = emission</div><div class="line">    <span class="comment"># 最优路径时，从起点到该节点的最高分</span></div><div class="line">    self.max_score = <span class="number">0.0</span></div><div class="line">    <span class="comment"># 最优路径时，该节点的下一个节点，用来输出路径的时候使用</span></div><div class="line">    self.next_node = <span class="keyword">None</span></div></pre></td></tr></table></figure>

<p>建立如下结构的词网格</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">ce      [册 测 测试 侧室 侧视 ... ]</div><div class="line">shi     [是 时 视频 食品 ...]</div><div class="line">pin     [拼 品 频 拼音  ...]</div><div class="line">yin     [银 音 因数 引述 ...]</div><div class="line">shu     [输入 输入法 树 输 书 ...]</div><div class="line">ru      [入 如 汝 入法 如法...]</div><div class="line">fa      [法 发 罚 伐 ...]</div></pre></td></tr></table></figure>

<p>]]>
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="HMM" scheme="http://yoursite.com/tags/HMM/"/>
    
      <category term="NLP" scheme="http://yoursite.com/tags/NLP/"/>
    
      <category term="pinyin" scheme="http://yoursite.com/tags/pinyin/"/>
    
      <category term="viterbi" scheme="http://yoursite.com/tags/viterbi/"/>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
      <category term="NLP" scheme="http://yoursite.com/categories/python/NLP/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[python实现简易中文输入法（二）：加载语言模型]]></title>
    <link href="http://yoursite.com/2014/12/12/python-simple-chinese-input-method-02/"/>
    <id>http://yoursite.com/2014/12/12/python-simple-chinese-input-method-02/</id>
    <published>2014-12-11T16:38:57.000Z</published>
    <updated>2014-12-14T07:57:05.000Z</updated>
    <content type="html"><![CDATA[<p>改编自<a href="http://sobuhu.com/ml/2013/03/07/hmm-pinyin-input-method.html" target="_blank" rel="external">搜不狐</a></p>
<p>分词和统计词频之后便是如何将数据模型加载到内存中</p>
<p>使用的词典文件结构：<br><img src="/img/pinyin-input-method/dict.png" alt="词典文件"><br>语料经过上个步骤的词频统计得到了一元、二元词频文件，结构如下：<br><a id="more"></a><br><img src="/img/pinyin-input-method/unigram.png" alt="一元词频"><br><img src="/img/pinyin-input-method/bigram.png" alt="二元词频"></p>
<p>下面我们开始加载语言模型。<br>一元和二元词频都放在同一个dict中</p>
<h2 id="加载一元词频">加载一元词频</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_unigram</span><span class="params">(self, filename)</span>:</span></div><div class="line">    f =  open(filename, <span class="string">'r'</span>)</div><div class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f:</div><div class="line">      key,freq = line.split()</div><div class="line">      self.freq[key] = int(freq)</div><div class="line">      self.unigram_count += <span class="number">1</span></div><div class="line">      self.words_count += int(freq)</div><div class="line">    f.close()</div></pre></td></tr></table></figure>

<h2 id="加载二元词频">加载二元词频</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_bigram</span><span class="params">(self, filename)</span>:</span></div><div class="line">    f =  open(filename, <span class="string">'r'</span>)</div><div class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f:</div><div class="line">      key,freq = line.split()</div><div class="line">      self.freq[key] = int(freq)</div><div class="line">    f.close()</div></pre></td></tr></table></figure>

<h2 id="加载发射概率（拼音对汉字）">加载发射概率（拼音对汉字）</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_emission</span><span class="params">(self, filename)</span>:</span></div><div class="line">    <span class="string">'''加载发射概率，针对多音字 如：</span></div><div class="line">     重 [zhong，chong]</div><div class="line">     则 [zhong][重] 的emssion 值为 2</div><div class="line">     使用时转换为 1/2</div><div class="line">    '''</div><div class="line">    <span class="keyword">with</span> open(filename,<span class="string">'r'</span>) <span class="keyword">as</span> f:</div><div class="line">      <span class="keyword">for</span> line <span class="keyword">in</span> f:</div><div class="line">        <span class="keyword">if</span> len(line.strip()) &gt; <span class="number">0</span>:</div><div class="line">          arr = line.strip().split()</div><div class="line">          key = arr[<span class="number">0</span>]</div><div class="line">          pinyin = <span class="string">'|'</span>.join([py <span class="keyword">for</span> py <span class="keyword">in</span> arr[<span class="number">2</span>:]])</div><div class="line"></div><div class="line">          <span class="keyword">if</span> pinyin <span class="keyword">not</span> <span class="keyword">in</span> self.emission:</div><div class="line">            self.emission[pinyin] = {}</div><div class="line">          <span class="comment"># 存储的概率是P(拼音|汉字),为了计算方便，所以用拼音做key</span></div><div class="line">          <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> self.emission[pinyin]:</div><div class="line">              self.emission[pinyin][key] = <span class="number">0</span></div><div class="line">          self.emission[pinyin][key] += <span class="number">1</span></div></pre></td></tr></table></figure>

<h2 id="获得转移概率">获得转移概率</h2>
<p>使用了最简单的<code>Lidstone</code>定律，即加λ平滑<code>(0&lt;λ&lt;1)</code><br>本例子中λ取0.5<br>实际应用中最为常见的平滑方法为<code>ktz平滑</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">bigram</span><span class="params">(self, word, condition)</span>:</span></div><div class="line">    <span class="string">'''获得转移概率'''</span></div><div class="line">    key = word + <span class="string">'|'</span> + condition</div><div class="line">    <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> self.freq:</div><div class="line">      self.freq[key] = <span class="number">0</span></div><div class="line">    <span class="keyword">if</span> condition <span class="keyword">not</span> <span class="keyword">in</span> self.freq:</div><div class="line">      self.freq[condition] = <span class="number">0</span></div><div class="line">    C_1 = (float)(self.freq[key] + <span class="number">0.5</span>)</div><div class="line">    C_2 = (float)(self.freq[condition] + <span class="number">0.5</span>*self.unigram_count)</div><div class="line">    <span class="keyword">return</span> C_1/C_2</div></pre></td></tr></table></figure>

<h2 id="获得初始概率">获得初始概率</h2>
<p>将一个词出现在句首的概率最为初始值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_init_score</span><span class="params">(self, word)</span>:</span></div><div class="line">    <span class="string">"""获得初始值"""</span></div><div class="line">    <span class="keyword">return</span> self.get_trans_pro(word, <span class="string">'&lt;li&gt;'</span>)</div></pre></td></tr></table></figure>

<h2 id="结语">结语</h2>
<p>语言模型的存储方式在实际应用中很重要，关系到整个输入法占用空间的大小<br>只是我太懒…就一股脑的全部加载到内存中了，有时间的话值得好好设计一下~<br>下面贴一个通用的存储模型：<br><img src="/img/pinyin-input-method/ngram-storge.png" alt="ngram存储结构"></p>
<h2 id="获得代码">获得代码</h2>
<p>代码已放到GitHub上：<a href="https://github.com/songboyu/NLP-test" target="_blank" rel="external">python实现简易中文输入法</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>改编自<a href="http://sobuhu.com/ml/2013/03/07/hmm-pinyin-input-method.html" target="_blank" rel="external">搜不狐</a></p>
<p>分词和统计词频之后便是如何将数据模型加载到内存中</p>
<p>使用的词典文件结构：<br><img src="/img/pinyin-input-method/dict.png" alt="词典文件"><br>语料经过上个步骤的词频统计得到了一元、二元词频文件，结构如下：<br>]]>
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="HMM" scheme="http://yoursite.com/tags/HMM/"/>
    
      <category term="NLP" scheme="http://yoursite.com/tags/NLP/"/>
    
      <category term="model" scheme="http://yoursite.com/tags/model/"/>
    
      <category term="ngram" scheme="http://yoursite.com/tags/ngram/"/>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
      <category term="NLP" scheme="http://yoursite.com/categories/python/NLP/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[python实现简易中文输入法（一）：分词、词频统计]]></title>
    <link href="http://yoursite.com/2014/12/11/python-simple-chinese-input-method-01/"/>
    <id>http://yoursite.com/2014/12/11/python-simple-chinese-input-method-01/</id>
    <published>2014-12-11T14:04:25.000Z</published>
    <updated>2014-12-13T11:15:33.000Z</updated>
    <content type="html"><![CDATA[<p>做一个NLP的实验当然要从最基本的步骤做起，那就是分词和词频统计</p>
<h2 id="分词">分词</h2>
<p>使用简单快速的正向最大匹配分词。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">fwd_mm_seg</span><span class="params">(wordDict, maxLen, str)</span>:</span></div><div class="line">    <span class="string">'''正向最大匹配分词</span></div><div class="line"></div><div class="line">    @param wordDict:    词表</div><div class="line">    @param maxLen:      词最大长度（自定义）</div><div class="line">    @param str:         待分词的字串</div><div class="line">    @return:            分词序列（List）</div><div class="line">    '''</div><div class="line">    wordList = []</div><div class="line">    segStr = str</div><div class="line">    segStrLen = len(segStr)</div><div class="line">    <span class="keyword">while</span> segStrLen &gt; <span class="number">0</span>:</div><div class="line">        <span class="keyword">if</span> segStrLen &gt; maxLen:</div><div class="line">            wordLen = maxLen</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            wordLen = segStrLen</div><div class="line">        subStr = segStr[<span class="number">0</span>:wordLen]</div><div class="line">        <span class="keyword">while</span> wordLen &gt; <span class="number">1</span>:</div><div class="line">            <span class="keyword">if</span> subStr <span class="keyword">in</span> wordDict:</div><div class="line">                <span class="keyword">break</span></div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                wordLen = wordLen - <span class="number">1</span></div><div class="line">                subStr = subStr[<span class="number">0</span>:wordLen]</div><div class="line">        wordList.append(subStr)</div><div class="line">        segStr = segStr[wordLen:]</div><div class="line">        segStrLen = segStrLen - wordLen</div><div class="line">    <span class="keyword">return</span> wordList</div></pre></td></tr></table></figure>

<p><a id="more"></a><br>使用96年人民日报作为测试语料，注意：</p>
<ol>
<li>读取文件时原文件的每一段作为一行输入给分词函数，以免词被分割。</li>
<li>每一短句（以, 。？ ！分割）作为一行输出，便于统计词频时计算词在行首的概率，作为viterbi算法的初始概率。</li>
<li>记得过滤空行以及特殊字符</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line">CODEC = <span class="string">'utf8'</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">file_seg_process</span><span class="params">(filename, method)</span>:</span></div><div class="line">    <span class="string">'''</span></div><div class="line">    @param filename: 文件名</div><div class="line">    @param method:   分词算法 { 0:正向，1:逆向 }</div><div class="line">    '''</div><div class="line">    <span class="comment"># 打开文件</span></div><div class="line">    fp_dict = open(<span class="string">'dict.txt'</span>)</div><div class="line">    fp_input = open(<span class="string">'corpus/'</span>+filename)</div><div class="line">    fp_output = open(<span class="string">'corpus_seg/'</span>+filename, <span class="string">'w'</span>)</div><div class="line">    </div><div class="line">    wordDict = {} </div><div class="line">    <span class="comment"># 读取字典到内存中</span></div><div class="line">    <span class="keyword">for</span> eachWord <span class="keyword">in</span> fp_dict:</div><div class="line">        wordDict[u(eachWord.split()[<span class="number">0</span>].strip(), CODEC)] = <span class="number">1</span></div><div class="line"></div><div class="line">    <span class="comment"># 对input每一行操作</span></div><div class="line">    str = <span class="string">''</span></div><div class="line">    <span class="keyword">for</span> eachLine <span class="keyword">in</span> fp_input:</div><div class="line">        line_out = <span class="string">''</span></div><div class="line">        <span class="comment"># 每一段作为一行输入给分词函数</span></div><div class="line">        sub = strQ2B(u(eachLine.strip(), CODEC))</div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> sub.startswith(<span class="string">'  '</span>):</div><div class="line">            str += sub</div><div class="line">            <span class="keyword">continue</span></div><div class="line">        strlen = len(str)</div><div class="line">        <span class="keyword">while</span> strlen &gt; <span class="number">0</span>:</div><div class="line">            <span class="comment"># 英文字符或数字--原文输出</span></div><div class="line">            m = re.match(<span class="string">r'\w+'</span>, str)</div><div class="line">            <span class="keyword">if</span> m <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</div><div class="line">                subStr = m.group()</div><div class="line">                line_out += subStr.encode(CODEC)+<span class="string">'/'</span></div><div class="line">                subLen = len(subStr)</div><div class="line">                str = str[subLen:]</div><div class="line">                strlen = strlen - subLen</div><div class="line">                <span class="keyword">continue</span></div><div class="line">            <span class="comment"># 短句结尾标志--输出换行</span></div><div class="line">            <span class="keyword">if</span> str[<span class="number">0</span>:<span class="number">1</span>].encode(CODEC) <span class="keyword">in</span> [<span class="string">','</span>,<span class="string">'。'</span>,<span class="string">'!'</span>,<span class="string">'?'</span>,<span class="string">':'</span>]:</div><div class="line">                subStr = str[<span class="number">0</span>:<span class="number">1</span>]</div><div class="line">                line_out += <span class="string">'\n'</span></div><div class="line">                subLen = len(subStr)</div><div class="line">                str = str[subLen:]</div><div class="line">                strlen = strlen - subLen</div><div class="line">            <span class="comment"># 汉字--分词处理，输出 词/词</span></div><div class="line">            m = re.match(<span class="string">ur'[\u4e00-\u9fa5]+'</span>, str)</div><div class="line">            <span class="keyword">if</span> m <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</div><div class="line">                subStr = m.group()</div><div class="line">                <span class="keyword">if</span> method == <span class="number">0</span>:</div><div class="line">                    <span class="comment"># 正向最大匹配</span></div><div class="line">                    wordList = fwd_mm_seg(wordDict, <span class="number">8</span>, subStr)</div><div class="line">                <span class="keyword">else</span>:</div><div class="line">                    <span class="comment"># 逆向最大匹配</span></div><div class="line">                    wordList = bwd_mm_seg(wordDict, <span class="number">8</span>, subStr)</div><div class="line">                line_out += wordList[<span class="number">0</span>].encode(CODEC)+<span class="string">'/'</span></div><div class="line">                <span class="keyword">for</span> eachWord <span class="keyword">in</span> wordList[<span class="number">1</span>:]:</div><div class="line">                    line_out += eachWord.encode(CODEC)+<span class="string">'/'</span></div><div class="line">                subLen = len(subStr)</div><div class="line">                str = str[subLen:]</div><div class="line">                strlen = strlen - subLen</div><div class="line">                <span class="keyword">continue</span></div><div class="line">            <span class="comment"># 其他特殊字符--跳过</span></div><div class="line">            str = str[<span class="number">1</span>:]</div><div class="line">            strlen = strlen - <span class="number">1</span></div><div class="line">        <span class="comment"># 跳过处理后为空行的段落</span></div><div class="line">        <span class="keyword">if</span> len(line_out.strip()) == <span class="number">0</span>:</div><div class="line">            <span class="keyword">continue</span></div><div class="line">        <span class="comment"># 写入文件</span></div><div class="line">        fp_output.write(line_out + <span class="string">'\n'</span>)</div><div class="line">        str = sub</div><div class="line">    <span class="comment"># close file</span></div><div class="line">    fp_input.close()</div><div class="line">    fp_dict.close()</div><div class="line">    fp_output.close()</div></pre></td></tr></table></figure>

<p>原文本<br><img src="/img/pinyin-input-method/1.png" alt="text"><br>分词处理后<br><img src="/img/pinyin-input-method/2.png" alt="text-seg"></p>
<h2 id="统计一元、二元词频">统计一元、二元词频</h2>
<p>预处理时将每一行处理为这样的格式<code>&lt;li&gt;我是一行字&lt;/li&gt;</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">scan</span><span class="params">(self, lines)</span>:</span></div><div class="line">    <span class="string">'''</span></div><div class="line">    逐行扫描，ngram结果记录到文件中</div><div class="line">    @param    sentence    list{str}</div><div class="line">    @return   none</div><div class="line">    '''</div><div class="line">    words = []</div><div class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> lines:</div><div class="line">        <span class="comment"># 统计n元词频</span></div><div class="line">        words.append(<span class="string">'&lt;li&gt;'</span>)</div><div class="line">        wordlist = [</div><div class="line">            w.encode(CODEC)</div><div class="line">            <span class="keyword">for</span> w <span class="keyword">in</span> list(line.decode(CODEC).split(<span class="string">'/'</span>))</div><div class="line">            <span class="keyword">if</span> len(w.strip())&gt;<span class="number">0</span></div><div class="line">        ]</div><div class="line">        words.extend(wordlist)</div><div class="line">        words.append(<span class="string">'&lt;/li&gt;'</span>)</div><div class="line"></div><div class="line">    self.ngram(words)</div><div class="line"></div><div class="line">    <span class="keyword">print</span> <span class="string">'[ Hashed ]'</span></div><div class="line"></div><div class="line">    <span class="comment">#unigram</span></div><div class="line">    file = open(<span class="string">"freq/word_freq.txt"</span>,<span class="string">"w"</span>)</div><div class="line">    <span class="keyword">for</span> key,value <span class="keyword">in</span> self.unigram.items():</div><div class="line">        file.write(<span class="string">"%s\t%d\n"</span> % (key, value))</div><div class="line">    file.close()</div><div class="line">    <span class="keyword">print</span> <span class="string">'[ Unigram file finish ]'</span></div><div class="line"></div><div class="line">    <span class="comment">#bigram</span></div><div class="line">    file = open(<span class="string">"freq/bigram_freq.txt"</span>,<span class="string">"w"</span>)</div><div class="line">    <span class="keyword">for</span> key,value <span class="keyword">in</span> self.bigram.items():</div><div class="line">        file.write(<span class="string">"%s\t%d\n"</span> % (key, value))</div><div class="line">    file.close()</div><div class="line">    <span class="keyword">print</span> <span class="string">'[ Bigram file finish ]'</span></div></pre></td></tr></table></figure>

<p>其中统计ngram的过程如下<br>统计词频时要把词和<code>&lt;li&gt;</code>频数都加入统计<br>这样即可得到一个词在句首的概率，可以表示为：<code>P(词|&lt;li&gt;)</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">ngram</span><span class="params">(self, words)</span>:</span></div><div class="line">    <span class="string">'''</span></div><div class="line">    统计ngram</div><div class="line">    @param    words       list{str}</div><div class="line">    @return   none</div><div class="line">    '''</div><div class="line">    partten = <span class="string">ur'([\u4e00-\u9fa5]|&lt;li&gt;|&lt;/li&gt;)+'</span></div><div class="line">    <span class="comment"># unigram</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(words)):</div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> re.search(partten, words[i].decode(CODEC)):</div><div class="line">            <span class="keyword">continue</span></div><div class="line">        key = words[i]</div><div class="line">        <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> self.unigram:</div><div class="line">            self.unigram[key] = <span class="number">0</span></div><div class="line">        self.unigram[key] += <span class="number">1</span></div><div class="line"></div><div class="line">    <span class="comment"># bigram</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(words)):</div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> re.search(partten, words[i].decode(CODEC)):</div><div class="line">            <span class="keyword">continue</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> re.search(partten, words[i-<span class="number">1</span>].decode(CODEC)):</div><div class="line">            <span class="keyword">continue</span></div><div class="line"></div><div class="line">        key = words[i] + <span class="string">'|'</span> + words[i-<span class="number">1</span>]</div><div class="line">        <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> self.bigram:</div><div class="line">            self.bigram[key] = <span class="number">0</span></div><div class="line">        self.bigram[key] += <span class="number">1</span></div></pre></td></tr></table></figure>

<h2 id="获得代码">获得代码</h2>
<p>代码已放到GitHub上：<a href="https://github.com/songboyu/NLP-test" target="_blank" rel="external">python实现简易中文输入法</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>做一个NLP的实验当然要从最基本的步骤做起，那就是分词和词频统计</p>
<h2 id="分词">分词</h2>
<p>使用简单快速的正向最大匹配分词。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">fwd_mm_seg</span><span class="params">(wordDict, maxLen, str)</span>:</span></div><div class="line">    <span class="string">'''正向最大匹配分词</span></div><div class="line"></div><div class="line">    @param wordDict:    词表</div><div class="line">    @param maxLen:      词最大长度（自定义）</div><div class="line">    @param str:         待分词的字串</div><div class="line">    @return:            分词序列（List）</div><div class="line">    '''</div><div class="line">    wordList = []</div><div class="line">    segStr = str</div><div class="line">    segStrLen = len(segStr)</div><div class="line">    <span class="keyword">while</span> segStrLen &gt; <span class="number">0</span>:</div><div class="line">        <span class="keyword">if</span> segStrLen &gt; maxLen:</div><div class="line">            wordLen = maxLen</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            wordLen = segStrLen</div><div class="line">        subStr = segStr[<span class="number">0</span>:wordLen]</div><div class="line">        <span class="keyword">while</span> wordLen &gt; <span class="number">1</span>:</div><div class="line">            <span class="keyword">if</span> subStr <span class="keyword">in</span> wordDict:</div><div class="line">                <span class="keyword">break</span></div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                wordLen = wordLen - <span class="number">1</span></div><div class="line">                subStr = subStr[<span class="number">0</span>:wordLen]</div><div class="line">        wordList.append(subStr)</div><div class="line">        segStr = segStr[wordLen:]</div><div class="line">        segStrLen = segStrLen - wordLen</div><div class="line">    <span class="keyword">return</span> wordList</div></pre></td></tr></table></figure>

<p>]]>
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="NLP" scheme="http://yoursite.com/tags/NLP/"/>
    
      <category term="ngram" scheme="http://yoursite.com/tags/ngram/"/>
    
      <category term="split" scheme="http://yoursite.com/tags/split/"/>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
      <category term="NLP" scheme="http://yoursite.com/categories/python/NLP/"/>
    
  </entry>
  
</feed>
